# 主要函数及其意义



## “old school”写法



### #`include <pthread.h>`



---







---



---



---





---



---





---





---





---



---





---

## ai的写法

发现ai写的代码没有用`pthread`库中的函数，但效果更简洁


### `#include <condition_variable>`


### `#include <thread>`

### `#include <mutex>`

# 练习题





## 两线程交替打印AB



### 使用`<pthread>`的写法

```C++
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

//互斥锁
pthread_mutex_t g_lock;

//同步
pthread_cond_t thread_a_cond; 
pthread_cond_t thread_b_cond;

int g_is_my_turn = 0;//为0时表示是A的回合，1为B的回合


void* thread_a_start(void* arg){
  (void)arg;//没有任何实际效果，只是防止编译器警告
  while(1){
    pthread_mutex_lock(&g_lock);
    while(g_is_my_turn == 1){
      pthread_cond_wait(&thread_a_cond, &g_lock);
    }
    printf("线程A打印-我是线程A\n");
    g_is_my_turn++;
    pthread_mutex_unlock(&g_lock);
    pthread_cond_signal(&thread_b_cond);
  }
}

void* thread_b_start(void* arg){
  (void)arg;
  while(1){
    sleep(1);
    pthread_mutex_lock(&g_lock);
    while(g_is_my_turn == 0){
      pthread_cond_wait(&thread_b_cond, &g_lock);
    }
    printf("线程B打印-我是线程B\n");
    g_is_my_turn--;
    pthread_mutex_unlock(&g_lock);
    pthread_cond_signal(&thread_a_cond);
  }
}





int main(){

  //初始化互斥锁与条件变量
  pthread_mutex_init(&g_lock, NULL);
  pthread_cond_init(&thread_a_cond, NULL);
  pthread_cond_init(&thread_b_cond, NULL);

  //创建线程AB
  pthread_t thread_a, thread_b;
  int ret = pthread_create(&thread_a, NULL, thread_a_start, NULL);
  if(ret < 0){
    perror("pthread_create");
    return 0;
  }
  ret = pthread_create(&thread_b, NULL, thread_b_start, NULL);
  if(ret < 0){
    perror("pthread_create");
    return 0;
  }

   
  pthread_join(thread_a, NULL);
  pthread_join(thread_b, NULL);
  pthread_mutex_destroy(&g_lock);
  pthread_cond_destroy(&thread_a_cond);
  pthread_cond_destroy(&thread_b_cond);
  return 0;

}
```



### ai的写法

```C++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

using namespace std;

mutex mtx;
condition_variable cv;
bool turn_A = true; // 控制该谁打印的标志

void printA() {
    while (true) {
        unique_lock<mutex> lock(mtx);
        // 等待直到轮到A打印
        cv.wait(lock, []{ return turn_A; });
        cout << "我是线程A" << endl;
        turn_A = false; // 切换控制权给B
        lock.unlock();
        cv.notify_one(); // 唤醒B线程
    }
}

void printB() {
    while (true) {
        unique_lock<mutex> lock(mtx);
        // 等待直到轮到B打印
        cv.wait(lock, []{ return !turn_A; });
        cout << "我是线程B" << endl;
        turn_A = true; // 切换控制权给A
        lock.unlock();
        cv.notify_one(); // 唤醒A线程
    }
}

int main() {
    thread tA(printA);
    thread tB(printB);
 
    tA.join();
    tB.join();
    
    return 0;
}

```



## 生产消费模型

### 条件变量+互斥锁实现线程安全的阻塞队列

#### 自己的写法

```C++

```







#### ai的写法

```c++

```







### 信号量+环形队列

#### 自己的写法

```
```







#### ai的写法

```
```



## 线程按顺序调度

leetcode链接：[http](https://leetcode.cn/problems/print-in-order/)[s:](https://leetcode.cn/problems/print-in-order/)[//leetcode-](https://leetcode.cn/problems/print-in-order/)[cn](https://leetcode.cn/problems/print-in-order/)[.](https://leetcode.cn/problems/print-in-order/)[com](https://leetcode.cn/problems/print-in-order/)[/problems/](https://leetcode.cn/problems/print-in-order/)[print](https://leetcode.cn/problems/print-in-order/)[-in-order/](https://leetcode.cn/problems/print-in-order/)

给你一个类：

```
public class Foo {
  public void first() { print("first"); }
  public void second() { print("second"); }
  public void third() { print("third"); }
}
```

三个不同的线程 A、B、C 将会共用一个 `Foo` 实例。

- 线程 A 将会调用 `first()` 方法
- 线程 B 将会调用 `second()` 方法
- 线程 C 将会调用 `third()` 方法

请设计修改程序，以确保 `second()` 方法在 `first()` 方法之后被执行，`third()` 方法在 `second()` 方法之后被执行。

**提示：**

- 尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。
- 你看到的输入格式主要是为了确保测试的全面性。

 

**示例 1：**

```txt
输入：nums = [1,2,3]
输出："firstsecondthird"
解释：
有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 second() 方法，线程 C 将会调用 third() 方法。正确的输出是 "firstsecondthird"。
```

**示例 2：**

```txt
输入：nums = [1,3,2]
输出："firstsecondthird"
解释：
输入 [1,3,2] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 third() 方法，线程 C 将会调用 second() 方法。正确的输出是 "firstsecondthird"。
```

**提示：**

- `nums` 是 `[1, 2, 3]` 的一组排列

参考题解：https://leetcode.cn/problems/print-in-order/solutions/445416/c-hu-chi-suo-tiao-jian-bian-liang-xin-hao-liang-yi

**参考题解答案**

```C++
class Foo {
    mutex mtx_1, mtx_2;
    unique_lock<mutex> lock_1, lock_2;
public:
    Foo() : lock_1(mtx_1, try_to_lock), lock_2(mtx_2, try_to_lock) {
    }

    void first(function<void()> printFirst) {
        printFirst();
        lock_1.unlock();
    }

    void second(function<void()> printSecond) {
        lock_guard<mutex> guard(mtx_1);
        printSecond();
        lock_2.unlock();
    }

    void third(function<void()> printThird) {
        lock_guard<mutex> guard(mtx_2);
        printThird();
    }
};

//作者：Chr1s
//链接：https://leetcode.cn/problems/print-in-order/solutions/445416/c-hu-chi-suo-tiao-jian-bian-liang-xin-hao-liang-yi/
//来源：力扣（LeetCode）
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```









## H2O类的同步设计

leetcode链接：[http](https://leetcode.cn/problems/building-h2o/)[s:](https://leetcode.cn/problems/building-h2o/)[//leetcode-](https://leetcode.cn/problems/building-h2o/)[cn](https://leetcode.cn/problems/building-h2o/)[.](https://leetcode.cn/problems/building-h2o/)[com](https://leetcode.cn/problems/building-h2o/)[/problems/building-h2o/](https://leetcode.cn/problems/building-h2o/)

参考题解：https://leetcode.cn/problems/building-h2o/solutions/2844856/xu-duo-shi-yong-suo-shi-xian-de-da-an-ro-1xyu

在有两种线程，氢 oxygen 和氧 hydrogen，你的目标是组织这两种线程来产生水分子。

 存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。

 氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。

 这些线程应该三三成组突破屏障并能立即组合产生一个水分子。

 你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。

 换句话说:

 如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。

 如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。

 书写满足这些限制条件的氢、氧线程同步代码。

```C++
class H2O {
 public:
  H2O() {
  }
  void hydrogen(function<void()> releaseHydrogen) {
    // releaseHydrogen() 输出 "H". Do not change or remove this line.
    releaseHydrogen();
  }
  void oxygen(function<void()> releaseOxygen) {
    // releaseOxygen() 输出 "O". Do not change or remove this line.
    releaseOxygen();
  }
 };
```

示例 1:

 输入: "HOH"

 输出: "HHO"

  解释: "HOH" 和 "OHH" 依然都是有效解。

 示例 2:

 输入: "OOHHHH"

 输出: "HHOHHO"

 解释: "HOHHHO", "OHHHHO", "HHOHOH", "HOHHOH", "OHHHOH", "HHOOHH", "HOHOHH" 和"OHHOHH" 依然都是有效解。







